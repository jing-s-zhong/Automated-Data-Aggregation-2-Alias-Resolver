!set variable_substitution=true;
use database &{db_name};
use schema &{sc_name};
--
USE DATABASE BI_TEST;
USE SCHEMA _CONTROL_LOGIC;
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- Generate some mapping data to create a test case
-------------------------------------------------------
-- Create some data relationship mapping tables
-------------------------------------------------------
--DROP TABLE _LOOKUP_INT_1;
CREATE OR REPLACE TABLE _LOOKUP_INT_1
AS
SELECT DATA_I1, CONCAT('GROUP_INT_1_', TO_VARCHAR(DATA_I1, '000')) DATA_A3
FROM (
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_1
  UNION ALL
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_2
  )
WHERE DATA_I1 IS NOT NULL
GROUP BY 1
;
--
--DROP TABLE _LOOKUP_INT_2;
CREATE OR REPLACE TABLE _LOOKUP_INT_2
AS
SELECT DATA_I2, CONCAT('GROUP_INT_2_', TO_VARCHAR(DATA_I2, '000')) DATA_A2, DATA_I2/15 SHARE
FROM (
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_1
  UNION ALL
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_2
  )
WHERE DATA_I2 IS NOT NULL
GROUP BY 1
;
--
--DROP TABLE _LOOKUP_INT_3;
CREATE OR REPLACE TABLE _LOOKUP_INT_3
AS
SELECT DATA_I3, CONCAT('GROUP_INT_3_', TO_VARCHAR(DATA_I3, '000')) DATA_A3, DATA_I3/10 RATE
FROM (
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_1
  UNION ALL
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_2
  )
WHERE DATA_I3 IS NOT NULL
GROUP BY 1
;
--
--DROP TABLE _MAPPING_CHAR_1;
CREATE OR REPLACE TABLE _MAPPING_CHAR_1
AS
SELECT DATA_A1,(ROW_NUMBER() OVER(ORDER BY DATA_A1))%16 DATA_I2
FROM (
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_1
  UNION ALL
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_2
  )
WHERE DATA_A1 IS NOT NULL
GROUP BY 1
;
--
--DROP TABLE _MAPPING_CHAR_2;
CREATE OR REPLACE TABLE _MAPPING_CHAR_2
AS
SELECT DATA_A2,(ROW_NUMBER() OVER(ORDER BY DATA_A2))%15 + 1 DATA_I3
FROM (
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_1
  UNION ALL
  SELECT * FROM BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_2
  )
WHERE DATA_A2 IS NOT NULL
GROUP BY 1
;
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- Describe/create the solution model of the test case
-------------------------------------------------------
-- Create the data warehouse model/template table
-------------------------------------------------------
DROP TABLE DATA_AGGREGATION_TEMPLATE;
CREATE OR REPLACE TRANSIENT TABLE DATA_AGGREGATION_TEMPLATE (
	DATA_PATTERN 		NUMBER,
	DATA_NAME 			VARCHAR,
	DATA_DATE 			DATE,
	DATA_HOUR 			NUMBER,
	DATA_TIME 			TIMESTAMP_NTZ,
	GROUP_INT_1 		NUMBER COMMENT 'BU_ID',         
	GROUP_INT_2 		NUMBER COMMENT 'NW_ID',
	OPTON_INT_3 		NUMBER COMMENT 'CNY_ID',
	GROUP_CHAR_1 		VARCHAR COMMENT 'NW',
	GROUP_CHAR_2 		VARCHAR COMMENT 'CNY',
	OPTION_CHAR_3 		VARCHAR COMMENT 'BU',
	FACTOR_SHARE 		FLOAT COMMENT 'SHARE',
	FACTOR_RATE 		FLOAT COMMENT 'RATE',
	VALUE_INT_1 		NUMBER COMMENT 'CNT1',
	VALUE_INT_2 		NUMBER COMMENT 'CNT2',
	VALUE_FLOAT_1 		FLOAT COMMENT 'LOC',
	VALUE_FLOAT_2 		FLOAT COMMENT 'INT'
);
--
SELECT *
FROM DATA_AGGREGATION_TEMPLATE
;
--
SELECT COLUMN_NAME, ORDINAL_POSITION
FROM INFORMATION_SCHEMA.COLUMNS
WHERE TABLE_CATALOG = 'BI_TEST'
AND TABLE_SCHEMA = '_CONTROL_LOGIC'
AND TABLE_NAME = 'DATA_AGGREGATION_TEMPLATE'
ORDER BY ORDINAL_POSITION
;
-------------------------------------------------------
-- Create the data landscape description model/template table
-------------------------------------------------------
CALL DATA_AGGREGATION_LANDSCAPE (
  'DATA_AGGREGATION_LANDSCAPE',
  'DATA_AGGREGATION_TEMPLATE',
  PARSE_JSON('["DATA_PATTERN","DATA_NAME","DATA_DATE","DATA_HOUR","DATA_TIME","GROUP_INT_1","GROUP_INT_2","OPTON_INT_3","GROUP_CHAR_1","GROUP_CHAR_2","OPTION_CHAR_3"]'),
  PARSE_JSON('["VALUE_INT_1","VALUE_INT_2","VALUE_FLOAT_1","VALUE_FLOAT_2"]')
  )
;
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- Describe/Configure the data landscapes overall
-------------------------------------------------------
-- Describe the data landscape of the mapping data
-------------------------------------------------------
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_MAPPING_CHAR_2';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'MAP_CNY','_MAPPING_CHAR_2','','','','','',
    '','','DATA_I3','','DATA_A2:LOWER(MAP_SOURCE)=LOWER(MAP_CNY)',
    '','','',
    '','','',''
    )
;
--
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_LOOKUP_INT_3';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'MAP_RATE','_LOOKUP_INT_3','','','','','',
    '','','DATA_I3:MAP_CNY=MAP_RATE','','',
    'DATA_A3','','RATE',
    '','','',''
    )
;
--
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_MAPPING_CHAR_1';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'MAP_NW','_MAPPING_CHAR_1','','','','','',
    '','DATA_I2','','DATA_A1:LOWER(MAP_SOURCE)=LOWER(MAP_NW)','',
    '','','',
    '','','',''
    )
;
--
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_LOOKUP_INT_2';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'LOOK_SHARE','_LOOKUP_INT_2','','','','','',
    '','DATA_I2:SOURCE_DATA=LOOK_SHARE','','','',
    '','SHARE','',
    '','','',''
    )
;
--
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_LOOKUP_INT_1';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'LOOK_BU','_LOOKUP_INT_1','','','','','',
    'DATA_I1:SOURCE_DATA=LOOK_BU','','','','',
    'DATA_A3','','',
    '','','',''
    )
;
-------------------------------------------------------
-- Describe the landscape of the source data
-------------------------------------------------------
select coalesce(a.DATA_PT,b.DATA_PT) DATA_PT, cnt1, cnt2
from (
  select DATA_PT, count(*) cnt1 
  from BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_1
  group by DATA_PT
  ) a
  full join (
  select DATA_PT, count(*) cnt2 
  from BI_TEST._CONTROL_LOGIC._TEST_DATA_SOURCE_2
  group by DATA_PT
  ) b
using (DATA_PT)
order by DATA_PT desc
;
--
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_TEST_DATA_SOURCE_1';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'SOURCE_DATA:MAP_SOURCE,MAP_CNY@INNER,MAP_RATE','_TEST_DATA_SOURCE_1','DATA_PT','\'_TEST_DATA_SOURCE_1\'','TO_DATE(DATA_TS)','DATE_PART(HOUR,DATA_TS)','DATA_TS',
    'DATA_I1','DATA_I2','COALESCE(MAP_CNY.DATA_I3,MAP_SOURCE.DATA_I3)','DATA_A1','MAP_SOURCE.DATA_A2',
    'COALESCE(MAP_RATE.DATA_A3,MAP_SOURCE.DATA_A3)','','MAP_RATE.RATE',
    'VALUE_I1','VALUE_I1','VALUE_D1','VALUE_D1*MAP_RATE.RATE'
    )
;
--
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = '_TEST_DATA_SOURCE_2';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'SOURCE_DATA:MAP_SOURCE,MAP_CNY@INNER,MAP_RATE,MAP_NW','_TEST_DATA_SOURCE_2','DATA_PT','\'_TEST_DATA_SOURCE_2\'','TO_DATE(DATA_TS)','DATE_PART(HOUR,DATA_TS)','DATA_TS',
    'DATA_I1','COALESCE(MAP_NW.DATA_I2,MAP_SOURCE.DATA_I2)','COALESCE(MAP_CNY.DATA_I3,MAP_SOURCE.DATA_I3)','MAP_SOURCE.DATA_A1','MAP_SOURCE.DATA_A2',
    'COALESCE(MAP_RATE.DATA_A3,MAP_SOURCE.DATA_A3)','','MAP_RATE.RATE',
    'VALUE_I1','VALUE_I1','VALUE_D1','VALUE_D1*MAP_RATE.RATE'
    )
;
-------------------------------------------------------
-- Describe the data landscape of the demand data
-------------------------------------------------------
DELETE FROM DATA_AGGREGATION_LANDSCAPE WHERE DATA_TABLE = 'DATA_AGGREGATION_TEMPLATE';
INSERT INTO DATA_AGGREGATION_LANDSCAPE (
    DATA_ALIAS,DATA_TABLE,DATA_PATTERN,DATA_NAME,DATA_DATE,DATA_HOUR,DATA_TIME,
    GROUP_INT_1,GROUP_INT_2,OPTON_INT_3,GROUP_CHAR_1,GROUP_CHAR_2,
    OPTION_CHAR_3,FACTOR_SHARE,FACTOR_RATE,
    VALUE_INT_1,VALUE_INT_2,VALUE_FLOAT_1,VALUE_FLOAT_2
    )
  VALUES (
    'TARGET_DATA:SOURCE_DATA,LOOK_BU,LOOK_SHARE','DATA_AGGREGATION_TEMPLATE','DATA_PATTERN','DATA_NAME','DATA_DATE','DATA_HOUR','DATA_TIME',
    'GROUP_INT_1','GROUP_INT_2','OPTON_INT_3','GROUP_CHAR_1','GROUP_CHAR_2',
    'OPTION_CHAR_3:LOOK_BU,SOURCE_DATA','FACTOR_SHARE:LOOK_SHARE,SOURCE_DATA','FACTOR_RATE',
    'VALUE_INT_1:SUM(?)','VALUE_INT_2:SUM(?)','VALUE_FLOAT_1:SUM(?),LOOK_SHARE.SHARE*(?)','VALUE_FLOAT_2:SUM(?),LOOK_SHARE.SHARE*(?)'
    )
;
--~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
-- Conduct a full testing against the aliasing reolver
-------------------------------------------------------
-- Register the template table as a aggregation target
-------------------------------------------------------
-- DELETE FROM DATA_AGGREGATION_TARGETS WHERE TARGET_TABLE = 'DATA_AGGREGATION_TEMPLATE';
MERGE INTO DATA_AGGREGATION_TARGETS D
USING (
  SELECT 'Test: aliasing resolver' TARGET_LABEL
  	,$1 TARGET_TABLE
  	,$2 BATCH_CONTROL_COLUMN
  	,$3 BATCH_CONTROL_SIZE
  	,$4 BATCH_CONTROL_NEXT
  	,DATEADD(MONTH, -1, DATE_TRUNC('MONTH', TO_TIMESTAMP_NTZ(CURRENT_TIMESTAMP(0)))) BATCH_PROCESSED
  	,NULL BATCH_PROCESSING
  	,NULL BATCH_MICROCHUNK_CURRENT
  	,$5 BATCH_SCHEDULE_TYPE
  	,NULL BATCH_SCHEDULE_LAST
  	,PARSE_JSON($6) PATTERN_COLUMNS
  	,PARSE_JSON($7) GROUPBY_COLUMNS
  	,DATA_PATTERN(PARSE_JSON($8)) GROUPBY_PATTERN
  	,True GROUPBY_FLEXIBLE
  	,PARSE_JSON($9) AGGREGATE_COLUMNS
  	,PARSE_JSON($10) AGGREGATE_FUNCTIONS
  	,NULL DEFAULT_PROCEDURE
  FROM VALUES (
  	'DATA_AGGREGATION_TEMPLATE'
  	,'DATA_TIME'
  	, 1440
  	,'DATEADD(MINUTE, :2, :1)'
  	,'MINUTES'
  	-- all group-by columns in source data
  	,'["DATA_PATTERN",
  		"DATA_NAME",
  		"DATA_DATE",
  		"DATA_HOUR",
  		"DATA_TIME",
  		"GROUP_INT_1",
  		"GROUP_INT_2",
  		"OPTON_INT_3",
  		"GROUP_CHAR_1",
  		"GROUP_CHAR_2",
  		"OPTION_CHAR_3"
        ]'
  	-- group-by columns of target data and which source column is the match
  	,'["DATA_PATTERN:DATA_PATTERN",
  		"DATA_NAME:DATA_NAME",
  		"DATA_DATE:DATA_DATE",
  		"DATA_HOUR:DATA_HOUR",
  		"DATA_TIME:DATA_TIME",
  		"GROUP_INT_1:GROUP_INT_1",
  		"GROUP_INT_2:GROUP_INT_2",
  		"OPTON_INT_3:OPTON_INT_3",
  		"GROUP_CHAR_1:GROUP_CHAR_1",
  		"GROUP_CHAR_2:GROUP_CHAR_2",
  		"OPTION_CHAR_3:OPTION_CHAR_3"
         ]'
  	-- indicators of which group-by column are needed in target table
  	,'[1,1,1,1,0,1,1,1,0,0,1]'
  	-- aggregate columns of target data and which aggregating column is the match
  	,'["VALUE_INT_1:VALUE_INT_1","VALUE_INT_2:VALUE_INT_2","VALUE_FLOAT_1:VALUE_FLOAT_1","VALUE_FLOAT_2:VALUE_FLOAT_2"]'
  	-- what aggregation function will be used for every aggregation column
  	,'["SUM(?)","COUNT(*)","SUM(?)","ROUND(AVG(?),2)"]'
  	)
  ) S
ON D.TARGET_TABLE = S.TARGET_TABLE
WHEN MATCHED THEN UPDATE SET ID = D.ID
  ,TARGET_LABEL = S.TARGET_LABEL
  ,TARGET_TABLE = S.TARGET_TABLE
  ,BATCH_CONTROL_COLUMN = S.BATCH_CONTROL_COLUMN
  ,BATCH_CONTROL_SIZE = S.BATCH_CONTROL_SIZE
  ,BATCH_CONTROL_NEXT = S.BATCH_CONTROL_NEXT
  ,BATCH_PROCESSED = S.BATCH_PROCESSED
  ,BATCH_PROCESSING = S.BATCH_PROCESSING
  ,BATCH_MICROCHUNK_CURRENT = S.BATCH_MICROCHUNK_CURRENT
  ,BATCH_SCHEDULE_TYPE = S.BATCH_SCHEDULE_TYPE
  ,BATCH_SCHEDULE_LAST = S.BATCH_SCHEDULE_LAST
  ,PATTERN_COLUMNS = S.PATTERN_COLUMNS
  ,GROUPBY_COLUMNS = S.GROUPBY_COLUMNS
  ,GROUPBY_PATTERN = S.GROUPBY_PATTERN
  ,GROUPBY_FLEXIBLE = S.GROUPBY_FLEXIBLE
  ,AGGREGATE_COLUMNS = S.AGGREGATE_COLUMNS
  ,AGGREGATE_FUNCTIONS = S.AGGREGATE_FUNCTIONS
  ,DEFAULT_PROCEDURE = S.DEFAULT_PROCEDURE
WHEN NOT MATCHED THEN INSERT (
	TARGET_LABEL
	,TARGET_TABLE
	,BATCH_CONTROL_COLUMN
	,BATCH_CONTROL_SIZE
	,BATCH_CONTROL_NEXT
	,BATCH_PROCESSED
	,BATCH_PROCESSING
	,BATCH_MICROCHUNK_CURRENT
	,BATCH_SCHEDULE_TYPE
	,BATCH_SCHEDULE_LAST
	,PATTERN_COLUMNS
	,GROUPBY_COLUMNS
	,GROUPBY_PATTERN
	,GROUPBY_FLEXIBLE
	,AGGREGATE_COLUMNS
	,AGGREGATE_FUNCTIONS
	,DEFAULT_PROCEDURE
	)
VALUES (
  S.TARGET_LABEL
	,S.TARGET_TABLE
	,S.BATCH_CONTROL_COLUMN
	,S.BATCH_CONTROL_SIZE
	,S.BATCH_CONTROL_NEXT
	,S.BATCH_PROCESSED
	,S.BATCH_PROCESSING
	,S.BATCH_MICROCHUNK_CURRENT
	,S.BATCH_SCHEDULE_TYPE
	,S.BATCH_SCHEDULE_LAST
	,S.PATTERN_COLUMNS
	,S.GROUPBY_COLUMNS
	,S.GROUPBY_PATTERN
	,S.GROUPBY_FLEXIBLE
	,S.AGGREGATE_COLUMNS
	,S.AGGREGATE_FUNCTIONS
	,S.DEFAULT_PROCEDURE
);
-------------------------------------------------------
-- Generate one aggregation source based on landscape
-------------------------------------------------------
CALL DATA_AGGREGATION_SOURCE_SETUP(
    'DATA_AGGREGATION_LANDSCAPE',
    'DATA_AGGREGATION_TEMPLATE',
    '_TEST_DATA_SOURCE_1',
    0)
;

--
-- visual check the newly added/updated source
--
SELECT *
FROM DATA_AGGREGATION_SOURCES
WHERE TARGET_TABLE = 'DATA_AGGREGATION_TEMPLATE'
AND SOURCE_ENABLED = False
;

--
-- Delete the existing data in test range, which will be regenerated by test call
--
DELETE FROM DATA_AGGREGATION_TEMPLATE
WHERE DATA_DATE >= DATEADD('MONTH', -1, DATE_TRUNC('MONTH', CURRENT_DATE()));


--
-- CALL DATA_AGGREGATOR ('<target table>', '<test date>', <script only>, <disabled only>);
--
CALL DATA_AGGREGATOR (
  'DATA_AGGREGATION_TEMPLATE', 
  DATEADD('MONTH', -1, DATE_TRUNC('MONTH', CURRENT_DATE())), 
  0, 
  1
);

--
-- Check the result generated by the test call
--
SELECT *
FROM DATA_AGGREGATION_TEMPLATE
WHERE DATA_DATE >= DATEADD('MONTH', -1, DATE_TRUNC('MONTH', CURRENT_DATE()));

--
-- Delete the result generated by the test call
--
DELETE FROM DATA_AGGREGATION_TEMPLATE
WHERE DATA_DATE >= DATEADD('MONTH', -1, DATE_TRUNC('MONTH', CURRENT_DATE()));

--
-- Enable the new added source after test it
--
UPDATE DATA_AGGREGATION_SOURCES
SET SOURCE_ENABLED = True
WHERE TARGET_TABLE = 'DATA_AGGREGATION_TEMPLATE'
AND SOURCE_ENABLED = False
;

-------------------------------------------------------
-- Generate all aggregation sources based on landscape
-------------------------------------------------------
CALL DATA_AGGREGATION_SOURCE_SETUP(
    'DATA_AGGREGATION_LANDSCAPE',
    'DATA_AGGREGATION_TEMPLATE',
    0
);

UPDATE DATA_AGGREGATION_SOURCES
SET SOURCE_ENABLED = True
WHERE TARGET_TABLE = 'DATA_AGGREGATION_TEMPLATE'
AND SOURCE_ENABLED = False
;

SELECT *
FROM DATA_AGGREGATION_SOURCES
WHERE TARGET_TABLE = 'DATA_AGGREGATION_TEMPLATE'
--AND SOURCE_ENABLED = False
;

-------------------------------------------------------
-- Generate all aggregation sources based on landscape
-------------------------------------------------------
CALL DATA_AGGREGATOR (
  'DATA_AGGREGATION_TEMPLATE', 
  DATEADD('MONTH', -1, DATE_TRUNC('MONTH', CURRENT_DATE())), 
  0
  )
;

select DATA_DATE, OPTION_CHAR_3, count(*) cnt
from DATA_AGGREGATION_TEMPLATE
group by DATA_DATE, OPTION_CHAR_3
order by DATA_DATE, OPTION_CHAR_3
;

truncate table DATA_AGGREGATION_TEMPLATE;

CALL DATA_AGGREGATOR ('DATA_AGGREGATION_TEMPLATE', 0);


